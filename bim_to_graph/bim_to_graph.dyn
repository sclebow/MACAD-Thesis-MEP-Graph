{
  "Uuid": "6c178a39-bd61-4438-b2c4-0036c99be1c2",
  "IsCustomNode": false,
  "Description": "",
  "Name": "bim_to_graph",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [
    {
      "Id": "13c26d2661194880a17bc8d4ef72c3be",
      "Name": "Directory Path",
      "Type": "string",
      "Type2": "string",
      "Value": "C:\\Users\\Scott\\Documents\\GitHub\\MACAD-Thesis-MEP-Graph\\bim_to_graph",
      "Description": "Allows you to select a directory on the system and returns its path"
    }
  ],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "# This is a Revit Dynamo script to convert the Electrical Equipment elements in a BIM model to a graph representation.\r\n\r\nimport os\r\nimport sys\r\nimport clr\r\nimport datetime\r\n\r\nclr.AddReference('ProtoGeometry')\r\nfrom Autodesk.DesignScript.Geometry import *\r\n\r\nclr.AddReference('RevitAPI')\r\nfrom Autodesk.Revit.DB import *\r\nfrom Autodesk.Revit.DB.Electrical import *\r\n\r\nclr.AddReference('RevitServices')\r\nimport RevitServices\r\nfrom RevitServices.Persistence import DocumentManager\r\n\r\ndef get_equipment_id_from_name(equipment_list, name):\r\n    for eq in equipment_list:\r\n        if eq.LookupParameter(\"Panel Name\") is None:\r\n            continue\r\n        eq_name = eq.LookupParameter(\"Panel Name\").AsString()\r\n        if eq_name == name:\r\n            return eq.Id.Value\r\n    return None\r\n\r\noutput_directory = IN[0]  # Input from Dynamo: directory to save the output file\r\n\r\nprint(\"\\n\" * 10)\r\n\r\n# Get all electrical equipment in the model\r\ndoc = DocumentManager.Instance.CurrentDBDocument\r\ncollector = FilteredElementCollector(doc)\r\nelectrical_equipment = collector.OfCategory(BuiltInCategory.OST_ElectricalEquipment).WhereElementIsNotElementType().ToElements()\r\n\r\nprint(\"Number of electrical equipment elements found: {}\".format(len(electrical_equipment)))\r\n\r\n# Get Project Information \r\nproject_info = doc.ProjectInformation\r\nproject_name = project_info.Name\r\nproject_number = project_info.Number\r\nissue_date = project_info.IssueDate\r\n\r\n# Format issue date to YYYY-MM-DD\r\nif issue_date:\r\n    try:\r\n        issue_date_dt = datetime.datetime.strptime(issue_date, \"%m/%d/%Y\")\r\n        issue_date = issue_date_dt.strftime(\"%Y-%m-%d\")\r\n    except Exception:\r\n        # If parsing fails, keep the original string\r\n        pass\r\n\r\nprint(f\"Project Name: {project_name}, Project Number: {project_number}, Issue Date: {issue_date}\")\r\n\r\n# Create a directed graph\r\nnodes = {}\r\nedges = {}\r\n\r\nALLOWABLE_NODE_TYPES = [\"Panelboard\", \"Switchboard\"]\r\nOUTPUT_ALL_NODE_PARAMS = False  # Set to True to output all parameters of nodes\r\n\r\n# Add nodes for each electrical equipment element\r\nfor eq in electrical_equipment:\r\n    symbol = doc.GetElement(eq.GetTypeId())\r\n    part_type = symbol.LookupParameter(\"Part Type\").AsValueString()\r\n    print(f\"Processing equipment ID {eq.Id.Value} of type {part_type}\")\r\n\r\n    if part_type not in ALLOWABLE_NODE_TYPES:\r\n        print(f\"Skipping equipment ID {eq.Id.Value} of type {part_type}\")\r\n        continue\r\n\r\n    # Check for required parameters\r\n    if eq.LookupParameter(\"Panel Name\") is None or eq.LookupParameter(\"Supply From\") is None:\r\n        print(f\"Skipping equipment ID {eq.Id.Value} due to missing required parameters\")\r\n        continue\r\n\r\n    # Check if \"Panel Name\" is empty or \"Supply From\" is empty\r\n    panel_name = eq.LookupParameter(\"Panel Name\").AsString()\r\n\r\n    if not panel_name:\r\n        print(f\"Skipping equipment ID {eq.Id.Value} due to empty required parameters\")\r\n        continue\r\n\r\n    node_dict = {}\r\n\r\n    if part_type == \"Panelboard\":\r\n        node_type = \"Panelboard\"\r\n        name = eq.LookupParameter(\"Panel Name\").AsString()\r\n        supply_from_name = eq.LookupParameter(\"Supply From\").AsString()\r\n        supply_from_id = get_equipment_id_from_name(electrical_equipment, supply_from_name)\r\n        node_dict = {\r\n            \"type\": node_type,\r\n            \"name\": name,\r\n            \"supply_from_name\": supply_from_name,\r\n            \"supply_from_id\": supply_from_id\r\n        }\r\n\r\n    elif part_type == \"Switchboard\":\r\n        node_type = \"Switchboard\"\r\n        name = eq.LookupParameter(\"Panel Name\").AsString()\r\n        supply_from_name = eq.LookupParameter(\"Supply From\").AsString()\r\n        supply_from_id = get_equipment_id_from_name(electrical_equipment, supply_from_name)\r\n        node_dict = {\r\n            \"type\": node_type,\r\n            \"name\": name,\r\n            \"supply_from_name\": supply_from_name,\r\n            \"supply_from_id\": supply_from_id\r\n        }\r\n\r\n    installation_date = issue_date  # Using project issue date as installation date\r\n    node_dict[\"installation_date\"] = installation_date\r\n\r\n    if OUTPUT_ALL_NODE_PARAMS:\r\n        for param in eq.Parameters:\r\n            try:\r\n                param_name = param.Definition.Name\r\n                if param.StorageType == StorageType.String:\r\n                    param_value = param.AsString()\r\n                elif param.StorageType == StorageType.Double:\r\n                    param_value = param.AsDouble()\r\n                elif param.StorageType == StorageType.Integer:\r\n                    param_value = param.AsInteger()\r\n                elif param.StorageType == StorageType.ElementId:\r\n                    param_value = str(param.AsElementId().IntegerValue)\r\n                else:\r\n                    param_value = None\r\n                node_dict[param_name] = param_value\r\n            except Exception as e:\r\n                print(f\"Error retrieving parameter {param.Definition.Name} for equipment ID {eq.Id.Value}: {e}\")\r\n\r\n    nodes[eq.Id.Value] = node_dict\r\n    print(f\"Added node: {node_dict}\")\r\n\r\nprint(f\"Nodes created: {len(nodes)}\")\r\n\r\n# Add edges based on supply relationships\r\nfor node_id, node_data in nodes.items():\r\n    supply_from_id = node_data[\"supply_from_id\"]\r\n    if supply_from_id and supply_from_id in nodes:\r\n        edges.setdefault(supply_from_id, []).append(node_id)\r\n        node_name = node_data[\"name\"]\r\n        supply_from_name = nodes[supply_from_id][\"name\"]\r\n        print(f\"Creating edge from {supply_from_name} (ID: {supply_from_id}) to {node_name} (ID: {node_id})\")\r\n\r\nprint(f\"Edges created: {sum(len(v) for v in edges.values())}\")\r\n\r\n# Output the graph in GraphML format\r\ngraphml_header = \"\"\"<?xml version='1.0' encoding='utf-8'?>\r\n<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">\r\n\"\"\"\r\ngraphml_footer = \"</graphml>\"\r\n\r\nnode_key_defs = []\r\nedge_key_defs = []\r\n\r\n# Define keys for node attributes\r\nnode_attributes = set()\r\nfor node_id, node_data in nodes.items():\r\n    for attr in node_data.keys():\r\n        node_attributes.add(attr)\r\n\r\n# Define keys for edge attributes\r\nedge_attributes = set()\r\nfor source, targets in edges.items():\r\n    for target in targets:\r\n        edge_attributes.add(\"source\")\r\n        edge_attributes.add(\"target\")\r\n\r\nfor attr in node_attributes:\r\n    node_key_defs.append(f'<key id=\"d{len(node_key_defs)+1}\" for=\"node\" attr.name=\"{attr}\" attr.type=\"string\"/>')\r\n\r\nfor attr in edge_attributes:\r\n    edge_key_defs.append(f'<key id=\"d{len(edge_key_defs)+1 + len(node_key_defs)}\" for=\"edge\" attr.name=\"{attr}\" attr.type=\"string\"/>')\r\n\r\ngraphml_content = graphml_header + \"\\n\".join(node_key_defs) + \"\\n\".join(edge_key_defs) + '<graph id=\"G\" edgedefault=\"directed\">\\n'\r\n\r\n# Add nodes to graphml\r\nfor node_id, node_data in nodes.items():\r\n    graphml_content += f'  <node id=\"n{node_id}\">\\n'\r\n    for attr, value in node_data.items():\r\n        graphml_content += f'    <data key=\"d{list(node_attributes).index(attr)+1}\">{value}</data>\\n'\r\n    graphml_content += '  </node>\\n'\r\n\r\n# Add edges to graphml\r\nfor source, targets in edges.items():\r\n    for target in targets:\r\n        graphml_content += f'  <edge source=\"n{source}\" target=\"n{target}\">\\n'\r\n        graphml_content += f'    <data key=\"d{len(node_attributes)+1}\">Edge from {source} to {target}</data>\\n'\r\n        graphml_content += '  </edge>\\n'\r\ngraphml_content += '</graph>\\n' + graphml_footer\r\nprint(\"GraphML content generated.\")\r\n\r\n# Save to file (optional)\r\nSAVE_TO_FILE = True\r\n\r\nif SAVE_TO_FILE:\r\n    output_path = os.path.join(output_directory, \"output_graph.graphml\")\r\n    with open(output_path, \"w\", encoding=\"utf-8\") as f:\r\n        f.write(graphml_content)\r\n    print(f\"GraphML file saved to {output_path}\")\r\n\r\nOUT = graphml_content",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "5fa3bd6e486049d9a7ede1c424ac1c7d",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "b3b5f496d14f4ea1a1183ba7ed0669fa",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "2541d17dd4e144ff85b72ed46e83638c",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "CoreNodeModels.Watch, CoreNodeModels",
      "WatchWidth": 420.0,
      "WatchHeight": 200.0,
      "Id": "fa275b73527443ceaee5b2c9960f7cda",
      "NodeType": "ExtensionNode",
      "Inputs": [
        {
          "Id": "679f54a45b9c44759df32a6b53acae04",
          "Name": "",
          "Description": "Node to show output from",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "e2ac4c8a61434e65b1aad1e5a856b4e1",
          "Name": "",
          "Description": "Node output",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Visualizes a node's output"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.Directory, CoreNodeModels",
      "Id": "13c26d2661194880a17bc8d4ef72c3be",
      "NodeType": "ExtensionNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "c60917aaac2b4436a94f5dfa22434019",
          "Name": "",
          "Description": "Directory path",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows you to select a directory on the system and returns its path",
      "HintPath": "C:\\Users\\Scott\\Documents\\GitHub\\MACAD-Thesis-MEP-Graph\\bim_to_graph",
      "InputValue": "C:\\Users\\Scott\\Documents\\GitHub\\MACAD-Thesis-MEP-Graph\\bim_to_graph"
    }
  ],
  "Connectors": [
    {
      "Start": "2541d17dd4e144ff85b72ed46e83638c",
      "End": "679f54a45b9c44759df32a6b53acae04",
      "Id": "c798fd64ab9d49d59e05b00c36161e19",
      "IsHidden": "False"
    },
    {
      "Start": "c60917aaac2b4436a94f5dfa22434019",
      "End": "b3b5f496d14f4ea1a1183ba7ed0669fa",
      "Id": "b38e2905e51c48f693543e3ee5f0b749",
      "IsHidden": "False"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [],
  "EnableLegacyPolyCurveBehavior": true,
  "Thumbnail": "",
  "GraphDocumentationURL": null,
  "ExtensionWorkspaceData": [
    {
      "ExtensionGuid": "28992e1d-abb9-417f-8b1b-05e053bee670",
      "Name": "Properties",
      "Version": "3.6",
      "Data": {}
    },
    {
      "ExtensionGuid": "DFBD9CC0-DB40-457A-939E-8C8555555A9D",
      "Name": "Generative Design",
      "Version": "9.1",
      "Data": {}
    }
  ],
  "Author": "",
  "Linting": {
    "activeLinter": "None",
    "activeLinterId": "7b75fb44-43fd-4631-a878-29f4d5d8399a",
    "warningCount": 0,
    "errorCount": 0
  },
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "3.6.0.9395",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "_Background Preview",
      "EyeX": -17.0,
      "EyeY": 24.0,
      "EyeZ": 50.0,
      "LookX": 12.0,
      "LookY": -13.0,
      "LookZ": -58.0,
      "UpX": 0.0,
      "UpY": 1.0,
      "UpZ": 0.0
    },
    "ConnectorPins": [],
    "NodeViews": [
      {
        "Id": "5fa3bd6e486049d9a7ede1c424ac1c7d",
        "Name": "Python Script",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 75.0,
        "Y": 681.0115837470456
      },
      {
        "Id": "fa275b73527443ceaee5b2c9960f7cda",
        "Name": "Watch",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 443.4227792455116,
        "Y": 823.8242966894508
      },
      {
        "Id": "13c26d2661194880a17bc8d4ef72c3be",
        "Name": "Directory Path",
        "IsSetAsInput": true,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -607.8836150621814,
        "Y": 685.7847920165525
      }
    ],
    "Annotations": [],
    "X": 733.0851705715854,
    "Y": -164.1506281442439,
    "Zoom": 0.6874295643133401
  }
}